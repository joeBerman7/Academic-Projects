# Extended System Programming Laboratory

Welcome to the **ESP Lab** repository! This course focuses on low-level systems programming, offering hands-on experience with C, assembly language, and direct interaction with Linux OS and system services. By the end of the course, students will gain an in-depth understanding of data, memory, system calls, and the low-level workings of computer architecture.
This repository gather all of my hard work during semester

## **Course Goals and Expectations**

### Goals:
- **Low-level systems-related programming** via hands-on experience.
- **Truly understanding data** through exploration of pointers, memory, and data structures.
- **Rudimentary assembly language programming** to get hands-on with the hardware-level interaction.
- Learn how to **RTFM** (Read The F***ing Manual), a crucial skill for troubleshooting and development.
- Cheating **will result in failing the course** and possible expulsion.

### Key Concepts Covered:
- **Programming in C**: Understanding code, pointers, and data manipulation.
- **Assembly language**: Basics and practical usage of assembly for low-level tasks.
- **Binary files**: Data structures in files, object code, executable files (ELF).
- **System calls**: Direct interaction with system services such as process handling, input, and output.
- **Low-level program development issues**: Debugging, patching, and hacking.

## **Course Overview**

### Why Bother?
You might wonder, "Why learn low-level systems programming when everything is in higher-level languages like Java and Python?" Hereâ€™s why:
- **Essential for understanding compilers, linkers, and OS design**.
- **Architecture impacts performance**. Writing programs that optimize for performance often requires understanding the hardware.
- **Some embedded systems only use assembly language**.
- Parts of the **operating system** and **security software** (e.g., anti-viruses) are still written in assembly.
- **Better understanding of security**, hacking, and reverse engineering.
